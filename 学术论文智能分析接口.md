# 四、 学术论文智能分析接口

## 1. 概览 

- **API 名称**: 学术论文智能分析API
- **接口状态**: `[稳定]`
- **接口描述**: 提供基于 MainScheduler 的端到端学术论文处理系统。它集成了PDF解析、元数据提取、摘要语步分析、论文脉络分析以及图表映射等核心功能，旨在为用户提供全面、结构化的论文洞察。

### 功能特性

- **PDF解析**: 自动解析PDF文件，提取文本、图表和元数据（标题、作者等）。
- **脉络分析**: 按照学术论文结构提取五大核心脉络内容。
- **摘要提取**: 智能提取摘要中的四个关键语步（背景、方法、创新点、局限）。
- **图表映射**: 将图表按所属脉络分类并建立映射关系。
- **并行处理**: 多线程并行执行，提高处理效率。
- **健康检查**: 内置健康状态检查接口，方便监控。

## 2. 核心接口: /paper_vis

此接口是系统的主要入口，接收一个PDF文件，执行完整的分析流程，并返回结构化的JSON结果。**<u>（可直接读取客户端的本地文件）</u>**

### 2.1. 请求

- **Endpoint (端点)**
  - `POST http://10.3.35.21:8004/paper_vis`
- **请求参数**
  - 请求体为 `multipart/form-data`，包含以下字段：

| 参数名 | 类型 | 是否必填 | 描述                    |
| ------ | ---- | -------- | ----------------------- |
| `file` | File | 是       | 用户上传的单个PDF文件。 |

- **备用请求方式**:
  - 除了上传文件，接口也支持通过JSON指定**服务器本地**的文件路径进行分析。
  - **Endpoint**: `POST http://10.3.35.21:8004/paper_vis`
  - **Headers**: `Content-Type: application/json`
  - **Body**: `{"pdf_path": "/path/on/server/to/paper.pdf"}`

### 2.2. 响应 

- **成功响应 **

  - **HTTP 状态码**: `200 OK`

  - **响应体 (JSON 示例)**:

    ```shell
    {
      "success": true,
      "metadata": {
        "title": "HYPOSPACE: EVALUATING LLM CREATIVITY AS SET-VALUED HYPOTHESIS GENERATORS UNDER UNDERDETERMINATION",
        "authors": ["作者1", "作者2", "作者3"]
      },
      "abstract": {
        "background_problem": "背景和问题描述",
        "method_approach": "方法和途径",
        "Innovation": "创新点",
        "Limitation/Future Work": "局限和未来工作"
      },
      "lanes": {
        "Context & Related Work": "相关工作和背景内容",
        "Methodology & Setup": "方法论和设置内容",
        "Results & Analysis": "结果和分析内容",
        "Conclusion": "结论内容",
        "Innovation Discovery": "学术创新机会发现"
      },
      "figure_map": {
        "Context & Related Work": [
          {
            "figure_id": "fig1",
            "caption": "图表标题",
            "content": "相关文本内容"
          }
        ],
        "Results & Analysis": [
          {
            "figure_id": "fig2",
            "caption": "结果图表",
            "content": "结果相关文本"
          }
        ]
      },
      "pdf_info": {
        "file_path": "/path/to/paper.pdf",
        "file_size": 1234567,
        "page_count": 10
      },
      "processing_info": {
        "steps_completed": ["pdf_parsing", "abstract_steps", "lane_extraction", "figure_mapping", "final_json_generation"],
        "total_time": 22.54,
        "success": true
      },
      "raw_data": {
        "md_content_length": 50000,
        "content_list_count": 150,
        "figure_dict_count": 8
      }
    
    ```

## 3. 辅助接口

用于监控服务的健康和运行状态。

### 3.1. GET /health

- **功能**: 检查服务是否健康，能否响应请求。

- **Endpoint**: `GET http://10.3.35.21:8004/health`

- **响应**:

  ```shell
  {
    "status": "healthy",
    "timestamp": "2025-01-27T10:30:00Z"
  }
  ```

### 3.2. GET /status

- **功能**: 获取服务的详细状态信息，如版本号、运行时长。

- **Endpoint**: `GET http://10.3.35.21:8004/status`

- **响应**:

  ```shell
  {
    "status": "running",
    "uptime": 3600,
    "version": "1.0.0"
  }
  ```

## 4. 调用示例

### 4.1. Python 请求

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
API测试客户端
测试文件上传接口 /paper_vis
"""

import requests
import json
import time
import os


def test_paper_vis_upload():
    """测试 /paper_vis 文件上传接口"""
    
    # API服务器地址
    base_url = "http://10.3.35.21:8004"
    
    # 测试PDF文件路径
    test_pdf_path = "/Users/xiaokong/Desktop/2510.15614v1.pdf"
    
    print("🧪 测试 /paper_vis 文件上传接口")
    print("=" * 60)
    
    # 检查文件是否存在
    if not os.path.exists(test_pdf_path):
        print(f"❌ 测试文件不存在: {test_pdf_path}")
        return
    
    print(f"📄 上传文件: {test_pdf_path}")
    print("⏳ 开始分析...")
    
    start_time = time.time()
    
    try:
        # 准备文件上传
        with open(test_pdf_path, 'rb') as f:
            files = {
                'file': (os.path.basename(test_pdf_path), f, 'application/pdf')
            }
            
            response = requests.post(
                f"{base_url}/paper_vis",
                files=files,
                timeout=300  # 5分钟超时
            )
        
        end_time = time.time()
        duration = end_time - start_time
        
        if response.status_code == 200:
            result = response.json()
            print("✅ 论文分析成功")
            print(f"⏱️ 总耗时: {duration:.2f}秒")
            print(f"📊 处理结果:")
            print(f"   - 成功状态: {result.get('success', False)}")
            print(f"   - 处理时间: {result.get('total_time', 0):.2f}秒")
            
            if result.get('success'):
                print(f"   - 论文标题: {result.get('metadata', {}).get('title', 'N/A')}")
                authors = result.get('metadata', {}).get('authors', [])
                print(f"   - 作者数量: {len(authors) if authors else 0}")
                lanes = result.get('lanes', {})
                print(f"   - 泳道数量: {len(lanes) if lanes else 0}")
                figure_map = result.get('figure_map', {})
                total_figures = sum(len(figures) for figures in figure_map.values()) if figure_map else 0
                print(f"   - 图表总数: {total_figures}")
                
                # 保存结果到文件
                output_file = "paper_vis_upload_result.json"
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(result, f, ensure_ascii=False, indent=2)
                print(f"💾 结果已保存到: {output_file}")
            else:
                print(f"❌ 分析失败: {result.get('error', '未知错误')}")
        else:
            print(f"❌ 论文分析失败: {response.status_code}")
            print(f"   错误信息: {response.text}")
            
    except requests.exceptions.Timeout:
        print("❌ 请求超时（5分钟）")
    except Exception as e:
        print(f"❌ 论文分析异常: {e}")
    
    print("\n" + "=" * 60)
    print("🏁 测试完成")


def test_server_health():
    """测试服务器健康状态"""
    base_url = "http://10.3.35.21:8004"
    
    try:
        # 直接测试 /paper_vis 接口的OPTIONS请求
        response = requests.options(f"{base_url}/paper_vis", timeout=10)
        if response.status_code in [200, 405]:  # 405表示方法不允许，但接口存在
            print("✅ 服务器运行正常")
            return True
        else:
            print(f"❌ 服务器响应异常: {response.status_code}")
            return False
    except Exception as e:
        print(f"❌ 无法连接到服务器: {e}")
        return False


if __name__ == "__main__":
    print("🚀 开始API测试")
    print("=" * 60)
    
    # 首先测试服务器健康状态
    if test_server_health():
        print("\n" + "=" * 60)
        # 测试文件上传接口
        test_paper_vis_upload()
    else:
        print("❌ 服务器不可用，请先启动API服务器")
        print("   运行命令: python api_server.py")
```

### 4.2. cURL 示例

```shell
# 方式一：上传本地文件进行分析
curl -X POST "[http://10.3.35.21:8004/paper_vis](http://10.3.35.21:8004/paper_vis)" \
  -F "file=@/path/to/your/paper.pdf"

# 方式二：分析服务器上的文件
curl -X POST "[http://10.3.35.21:8004/paper_vis](http://10.3.35.21:8004/paper_vis)" \
  -H "Content-Type: application/json" \
  -d '{"pdf_path": "/path/on/server/to/paper.pdf"}'

# 检查健康状态
curl -X GET "[http://10.3.35.21:8004/health](http://10.3.35.21:8004/health)"
```

### 4.3. JavaScript (Fetch API) 示例

```javascript
/**
 * 论文分析API客户端
 */

// API基础URL - 使用代理路径避免CORS问题
const API_BASE_URL = process.env.NODE_ENV === 'development' ? '/api' : 'http://10.3.35.21:8004'

/**
 * 上传PDF文件并进行分析
 * @param {File} pdfFile - PDF文件对象
 * @param {Function} onProgress - 进度回调函数
 * @returns {Promise<Object>} 分析结果
 */
export async function analyzePaper(pdfFile, onProgress = null) {
  try {
    console.log('🚀 开始论文分析...')
    console.log('📄 文件信息:', {
      name: pdfFile.name,
      size: pdfFile.size,
      type: pdfFile.type
    })

    // 验证文件类型
    if (pdfFile.type !== 'application/pdf') {
      throw new Error('请选择PDF文件')
    }

    // 创建FormData
    const formData = new FormData()
    formData.append('file', pdfFile)

    // 显示进度
    if (onProgress) {
      onProgress(10, '准备上传文件...')
    }

    const startTime = Date.now()

    // 发送请求到 /paper_vis 接口
    const response = await fetch(`${API_BASE_URL}/paper_vis`, {
      method: 'POST',
      body: formData,
      mode: 'cors', // 明确指定CORS模式
      headers: {
        // 不设置Content-Type，让浏览器自动设置multipart/form-data
      },
      // 注意：fetch不支持进度回调，这里我们模拟进度
    })

    const endTime = Date.now()
    const duration = (endTime - startTime) / 1000

    if (!response.ok) {
      throw new Error(`服务器错误: ${response.status} ${response.statusText}`)
    }

    const result = await response.json()

    console.log('✅ 论文分析完成')
    console.log('⏱️ 总耗时:', duration.toFixed(2), '秒')
    console.log('📊 处理结果:', result)

    // 验证返回结果
    if (!result.success) {
      throw new Error(result.error || '分析失败')
    }

    // 显示最终进度
    if (onProgress) {
      onProgress(100, '分析完成！')
    }

    return {
      success: true,
      data: result,
      duration: duration,
      metadata: {
        title: result.metadata?.title || '未知标题',
        authors: result.metadata?.authors || [],
        totalTime: result.total_time || duration,
        lanesCount: Object.keys(result.lanes || {}).length,
        figuresCount: Object.values(result.figure_map || {}).reduce((total, figures) => total + figures.length, 0)
      }
    }

  } catch (error) {
    console.error('❌ 论文分析失败:', error)
    
    // 检查是否是CORS错误
    let errorMessage = error.message || '未知错误'
    if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
      errorMessage = '跨域请求被阻止，请检查后端服务器CORS配置或使用代理'
    }
    
    // 显示错误进度
    if (onProgress) {
      onProgress(0, `分析失败: ${errorMessage}`)
    }

    return {
      success: false,
      error: errorMessage,
      data: null
    }
  }
}

/**
 * 检查服务器健康状态
 * @returns {Promise<boolean>} 服务器是否可用
 */
export async function checkServerHealth() {
  try {
    const response = await fetch(`${API_BASE_URL}/paper_vis`, {
      method: 'OPTIONS',
      timeout: 10000
    })
    
    // 200或405都表示接口存在
    return response.status === 200 || response.status === 405
  } catch (error) {
    console.warn('服务器健康检查失败:', error)
    return false
  }
}

/**
 * 模拟进度更新（因为fetch不支持进度回调）
 * @param {Function} onProgress - 进度回调函数
 * @param {number} duration - 预计总时长（秒）
 */
export function simulateProgress(onProgress) {
  let progress = 0
  const interval = setInterval(() => {
    progress += Math.random() * 10
    if (progress >= 90) {
      progress = 90
      clearInterval(interval)
    }
    
    const statuses = [
      '正在上传文件...',
      'PDF解析中...',
      '内容抽取中...',
      '语义分析中...',
      '生成结果中...'
    ]
    
    const statusIndex = Math.floor((progress / 100) * statuses.length)
    const status = statuses[Math.min(statusIndex, statuses.length - 1)]
    
    onProgress(Math.floor(progress), status)
  }, 1000)

  return interval
}

```

## 5. 注意事项

1. **文件路径**: 使用JSON请求时，请确保 `pdf_path` 是服务器可访问的绝对路径。
2. **处理时间**: 大型或复杂的PDF论文可能需要较长的处理时间，客户端应设置足够长的超时时间（建议2分钟以上）。
3. **文件格式**: 目前仅支持标准的PDF格式文件。

## 运维笔记

- **接口端口**: `8004`

- **配置项地址**: `/etc/systemd/system/paper-vis-api.service`

- **代码位置**: `/data/kongyb/paper_vis/paper_vis/api_server.py`

- **接口源代码**:

  ```python
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  FastAPI 服务器 - 学术论文智能分析接口
  基于 MainScheduler 的完整论文处理系统
  
  唯一接口：
  POST /paper_vis
  - 输入：上传PDF文件
  - 输出：MainScheduler的完整JSON结果
  """
  from fastapi.middleware.cors import CORSMiddleware
  from fastapi import FastAPI, HTTPException, UploadFile, File
  import uvicorn
  
  # 导入主调度器
  from MainScheduler import MainScheduler
  
  
  # 创建FastAPI应用
  app = FastAPI(
      title="学术论文智能分析API",
      description="基于AI的学术论文智能分析系统",
      version="1.0.0"
  )
  
  origins = ["*"]
  
  # 将 CORS 中间件添加到你的应用中
  app.add_middleware(
      CORSMiddleware,
      allow_origins=origins,  # 使用新的 origins 列表
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  
  @app.post("/paper_vis")
  async def paper_vis(file: UploadFile = File(...)):
      """
      分析PDF论文 - 唯一接口
      
      输入：
      - file: 上传的PDF文件
      
      输出：
      - MainScheduler的完整JSON结果
      """
      try:
          print(f"🚀 开始处理PDF文件: {file.filename}")
          
          # 检查文件类型
          if not file.filename.lower().endswith('.pdf'):
              raise HTTPException(
                  status_code=400, 
                  detail="只支持PDF文件格式"
              )
          
          # 读取上传的文件内容
          file_content = await file.read()
          
          # 创建主调度器实例
          scheduler = MainScheduler()
          
          # 执行完整的论文分析流程（直接使用文件内容，不保存到服务器）
          result = scheduler.process_uploaded_pdf(file_content, file.filename)
          
          return result
              
      except Exception as e:
          print(f"❌ 服务器内部错误: {e}")
          raise HTTPException(
              status_code=500,
              detail=f"服务器内部错误: {str(e)}"
          )
  
  
  if __name__ == "__main__":
      print("🚀 启动学术论文智能分析API服务器...")
      print("📡 服务地址: http://10.3.35.21:8004")
      print("📊 唯一接口: POST /paper_vis")
      print("=" * 60)
      
      # 启动服务器
      uvicorn.run(
          "api_server:app",
          host="0.0.0.0",
          port=8004,
          reload=True,
          log_level="info"
      )
  ```

  # 五、 学术论文智能分析服务平台 

  ## 1. 概览

  - **平台名称**: 学术论文智能分析服务平台
  - **平台状态**: `[稳定]`
  - **平台描述**: 本平台是“学术论文智能分析API”的可视化前端界面，为用户提供了一个便捷的图形化操作窗口，可以直接上传PDF文件，并直观地查看分析结果。

  ![50a3614bcb6612ad37ba3bce27bfd143](/Users/xiaokong/Library/Containers/com.tencent.xinWeChat/Data/Documents/xwechat_files/wxid_e0erez0j9yre22_7560/temp/RWTemp/2025-10/50a3614bcb6612ad37ba3bce27bfd143.png)

  ![7f5bea41e11b370867ebba38be801295](/Users/xiaokong/Library/Containers/com.tencent.xinWeChat/Data/Documents/xwechat_files/wxid_e0erez0j9yre22_7560/temp/RWTemp/2025-10/7f5bea41e11b370867ebba38be801295.png)

  ![338bb8e07c311fcc83a19cebbf1fbd44](/Users/xiaokong/Library/Containers/com.tencent.xinWeChat/Data/Documents/xwechat_files/wxid_e0erez0j9yre22_7560/temp/RWTemp/2025-10/338bb8e07c311fcc83a19cebbf1fbd44.png)

  ## 2. 访问地址

  - **平台访问链接**:
    - `http://10.3.35.21:8080/upload`

  ## 3. 注意事项

  1. **浏览器兼容性**: 建议使用最新版本的 Chrome, Firefox, 或 Edge 浏览器以获得最佳体验。
  2. **文件上传**: 用户通过此平台上传的PDF文件，将由后端“学术论文智能分析API” (`http://10.3.35.21:8004`) 进行处理。
  3. **网络环境**: 请确保客户端能够访问服务器 `10.3.35.21` 的 `8080` 端口。

  ## 运维记录

  - **服务端口**: `8080`

  - **Web服务器配置**: `/etc/nginx/sites-enabled/paper-vis-frontend`

  - **项目代码位置**: `/data/kongyb/paper_vis/frontend/`

    

    